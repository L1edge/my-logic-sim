// === 1. ОЧИЩЕННЯ ІМЕН ===
const createNamingMap = (nodes) => {
  const map = new Map();
  let inputCount = 0;
  let outputCount = 0;
  let wireCount = 0;

  nodes.forEach(node => {
    let rawLabel = node.data.label || '';
    let cleanLabel = rawLabel.replace(/[^a-zA-Z0-9]/g, '_');
    
    if (!cleanLabel || /^\d/.test(cleanLabel)) {
        cleanLabel = `n_${cleanLabel || node.id.replace(/-/g, '_')}`;
    }

    const reservedWords = ['in', 'out', 'signal', 'component', 'entity', 'architecture', 'begin', 'end', 'process', 'if', 'then', 'else', 'case', 'when', 'with', 'select', 'library', 'use', 'all', 'of', 'is', 'map', 'port', 'and', 'or', 'not', 'xor', 'nand', 'nor'];
    if (reservedWords.includes(cleanLabel.toLowerCase())) {
        cleanLabel = `s_${cleanLabel}`;
    }

    if (node.type === 'inputNode') {
      map.set(node.id, cleanLabel || `input_${++inputCount}`);
    } else if (node.type === 'outputNode') {
      map.set(node.id, cleanLabel || `output_${++outputCount}`);
    } else {
      map.set(node.id, `wire_${++wireCount}`);
    }
  });
  return map;
};

// === 2. VERILOG GENERATOR ===
export const generateVerilog = (nodes, edges, moduleName = 'LogicSim_Circuit') => {
  const map = createNamingMap(nodes);
  moduleName = moduleName.replace(/\s+/g, '_');
  
  let code = `/* Generated by LogicSim Pro */\n`;
  code += `\`timescale 1ns / 1ps\n\n`;
  code += `module ${moduleName} (\n`;

  const inputs = nodes.filter(n => n.type === 'inputNode');
  const outputs = nodes.filter(n => n.type === 'outputNode');

  const portDecls = [
    ...inputs.map(n => `    input ${map.get(n.id)}`),
    ...outputs.map(n => `    output ${map.get(n.id)}`)
  ];

  code += portDecls.join(',\n');
  code += `\n);\n\n`;

  code += `    // Internal signals\n`;
  nodes.forEach(node => {
    if (node.type === 'logicGate' || node.type === 'constantNode') {
      code += `    wire ${map.get(node.id)};\n`;
    }
  });
  code += `\n`;

  nodes.forEach(node => {
    const outputWire = map.get(node.id);

    if (node.type === 'constantNode') {
      const val = node.data.constantValue !== undefined ? node.data.constantValue : 0;
      code += `    assign ${outputWire} = 1'b${val};\n`;
    }

    if (node.type === 'logicGate') {
      let type = node.data.type || 'AND';
      if (type.includes('NOT')) type = 'NOT';

      const inputEdges = edges.filter(e => e.target === node.id);
      const inputWires = inputEdges.map(edge => {
        const sourceNode = nodes.find(n => n.id === edge.source);
        return sourceNode ? map.get(sourceNode.id) : "1'b0";
      });

      const neededInputs = type === 'NOT' ? 1 : (node.data.inputs || 2);
      const safeVal = (type === 'AND' || type === 'NAND') ? "1'b1" : "1'b0";
      
      while (inputWires.length < neededInputs) {
        inputWires.push(safeVal);
      }

      let expression = "";
      if (type === 'NOT') {
        expression = `~${inputWires[0]}`;
      } else {
        const op = (type === 'AND' || type === 'NAND') ? '&' :
                   (type === 'OR'  || type === 'NOR')  ? '|' :
                   (type === 'XOR') ? '^' : '&';
        
        expression = inputWires.join(` ${op} `);
        if (type === 'NAND' || type === 'NOR') expression = `~(${expression})`;
      }

      code += `    assign ${outputWire} = ${expression};\n`;
    }
  });

  code += `\n    // Output Connections\n`;
  outputs.forEach(outNode => {
    const edge = edges.find(e => e.target === outNode.id);
    const outName = map.get(outNode.id);
    code += `    assign ${outName} = ${edge ? map.get(edge.source) : "1'b0"};\n`;
  });

  code += `\nendmodule\n`;
  return code;
};

// === 3. VHDL GENERATOR (FIXED) ===
export const generateVHDL = (nodes, edges, entityName = 'LogicSim_Circuit') => {
  const map = createNamingMap(nodes);
  if (/^\d/.test(entityName)) entityName = 'Circuit_' + entityName;
  entityName = entityName.replace(/\s+/g, '_');

  let code = `-- Generated by LogicSim Pro\nlibrary IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\n\n`;
  
  code += `entity ${entityName} is\n    Port (\n`;
  
  const inputs = nodes.filter(n => n.type === 'inputNode');
  const outputs = nodes.filter(n => n.type === 'outputNode');
  
  const ports = [
    ...inputs.map(n => `           ${map.get(n.id)} : in STD_LOGIC`),
    ...outputs.map(n => `           ${map.get(n.id)} : out STD_LOGIC`)
  ];
  
  code += ports.join(';\n');
  code += `\n    );\nend ${entityName};\n\n`;

  code += `architecture Behavioral of ${entityName} is\n`;
  
  nodes.forEach(node => {
    if (node.type === 'logicGate' || node.type === 'constantNode') {
      code += `    signal ${map.get(node.id)} : STD_LOGIC;\n`;
    }
  });

  code += `begin\n\n`;

  nodes.forEach(node => {
    const outSig = map.get(node.id);
    
    if (node.type === 'constantNode') {
       const val = node.data.constantValue || 0;
       code += `    ${outSig} <= '${val}';\n`;
    }

    if (node.type === 'logicGate') {
      let type = node.data.type || 'AND';
      if (type.includes('NOT')) type = 'NOT';

      const inputEdges = edges.filter(e => e.target === node.id);
      const inputSigs = inputEdges.map(e => {
        const src = nodes.find(n => n.id === e.source);
        return src ? map.get(src.id) : null;
      }).filter(s => s !== null);
      
      const neededInputs = type === 'NOT' ? 1 : (node.data.inputs || 2);
      const safeVal = (type === 'AND' || type === 'NAND') ? "'1'" : "'0'";
      while(inputSigs.length < neededInputs) inputSigs.push(safeVal);

      if (type === 'NOT') {
        code += `    ${outSig} <= not ${inputSigs[0]};\n`;
      } else {
        // === ЖОРСТКИЙ SWITCH ДЛЯ ОПЕРАТОРІВ (Щоб не було "ad") ===
        let op = 'and';
        let isInverted = false;

        switch(type) {
            case 'AND': op = 'and'; break;
            case 'OR':  op = 'or';  break;
            case 'XOR': op = 'xor'; break;
            case 'NAND': op = 'and'; isInverted = true; break;
            case 'NOR':  op = 'or';  isInverted = true; break;
            default: op = 'and'; break;
        }
        
        let expr = "";
        if (inputSigs.length > 0) {
            expr = inputSigs.join(` ${op} `);
            expr = `(${expr})`; // Дужки обов'язкові для VHDL
        } else {
            expr = safeVal;
        }

        if (isInverted) {
            code += `    ${outSig} <= not ${expr};\n`;
        } else {
            code += `    ${outSig} <= ${expr};\n`;
        }
      }
    }
  });

  outputs.forEach(outNode => {
    const edge = edges.find(e => e.target === outNode.id);
    const outName = map.get(outNode.id);
    const srcName = edge ? map.get(edge.source) : "'0'";
    code += `    ${outName} <= ${srcName};\n`;
  });

  code += `\nend Behavioral;\n`;
  return code;
};

// === 4. TESTBENCH GENERATOR ===
export const generateTestbench = (nodes, moduleName = 'LogicSim_Circuit') => {
  if (/^\d/.test(moduleName)) moduleName = 'Circuit_' + moduleName;
  moduleName = moduleName.replace(/\s+/g, '_');
    
  const map = createNamingMap(nodes);
  const inputs = nodes.filter(n => n.type === 'inputNode');
  const outputs = nodes.filter(n => n.type === 'outputNode');
  const tbName = `${moduleName}_tb`;

  let code = `\`timescale 1ns / 1ps\n\nmodule ${tbName};\n\n`;

  inputs.forEach(n => code += `    reg ${map.get(n.id)};\n`);
  outputs.forEach(n => code += `    wire ${map.get(n.id)};\n`);

  code += `\n    ${moduleName} uut (\n`;
  const connections = [
    ...inputs.map(n => `        .${map.get(n.id)}(${map.get(n.id)})`),
    ...outputs.map(n => `        .${map.get(n.id)}(${map.get(n.id)})`)
  ];
  code += connections.join(',\n');
  code += `\n    );\n\n    initial begin\n`;
  
  inputs.forEach(n => code += `        ${map.get(n.id)} = 0;\n`);
  code += `        #100;\n\n`;

  const limit = Math.min(inputs.length, 6); 
  const combinations = 1 << limit;
  for(let i = 0; i < combinations; i++) {
     inputs.slice(0, limit).forEach((n, idx) => {
        const bit = (i >> idx) & 1;
        code += `        ${map.get(n.id)} = ${bit};\n`;
     });
     code += `        #20;\n`;
  }
  code += `        $finish;\n    end\n\nendmodule\n`;
  return code;
};