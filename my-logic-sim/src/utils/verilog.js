// Очищує імена, щоб не було пробілів та спецсимволів
const sanitize = (str) => (str || '').replace(/[^a-zA-Z0-9_]/g, '_') || 'wire';

export const generateVerilog = (nodes, edges) => {
  let code = `/* Generated by LogicSim */\n`;
  code += `module LogicSim_Circuit (\n`;
  
  // 1. Знаходимо входи (InputNode) і виходи (OutputNode)
  const inputs = nodes.filter(n => n.type === 'inputNode');
  const outputs = nodes.filter(n => n.type === 'outputNode');
  
  // Генеруємо список портів
  const portList = [
    ...inputs.map(n => `    input ${sanitize(n.data.label || `in_${n.id}`)}`),
    ...outputs.map(n => `    output ${sanitize(n.data.label || `out_${n.id}`)}`)
  ];
  
  code += portList.join(',\n');
  code += `\n);\n\n`;

  code += `    // Internal wires (з'єднання між гейтами)\n`;
  
  // 2. Оголошуємо дроти для виходів усіх логічних гейтів
  nodes.forEach(node => {
    if (node.type === 'logicGate') {
       code += `    wire wire_${sanitize(node.id)};\n`;
    }
  });
  code += `\n`;

  // 3. Генеруємо логіку (assign)
  nodes.forEach(node => {
    if (node.type === 'logicGate') {
      const type = node.data.type; // AND, OR...
      const outputWire = `wire_${sanitize(node.id)}`;
      
      // Знаходимо всі вхідні з'єднання до цього гейта
      // Важливо: сортуємо по input-0, input-1, щоб порядок був правильний (хоча для AND/OR це не важливо, для дебагу приємно)
      const inputEdges = edges
        .filter(e => e.target === node.id)
        .sort((a, b) => (a.targetHandle || '').localeCompare(b.targetHandle || ''));
      
      // Перетворюємо з'єднання в імена проводів
      const inputWires = inputEdges.map(edge => {
        const sourceNode = nodes.find(n => n.id === edge.source);
        if (!sourceNode) return "1'b0"; // Якщо джерело видалили

        if (sourceNode.type === 'inputNode') return sanitize(sourceNode.data.label || `in_${sourceNode.id}`);
        if (sourceNode.type === 'logicGate') return `wire_${sanitize(sourceNode.id)}`;
        if (sourceNode.type === 'constantNode') return `1'b${sourceNode.data.value}`; // 1'b0 або 1'b1
        return "1'b0"; 
      });

      // Якщо гейт має вільні входи, заповнюємо їх безпечними значеннями
      // Для AND/NAND це 1 (щоб не впливати), для OR/XOR це 0.
      const safeVal = (type === 'AND' || type === 'NAND') ? "1'b1" : "1'b0";
      while (inputWires.length < (node.data.inputs || 2)) {
        inputWires.push(safeVal);
      }

      // Формуємо вираз
      let expression = "";
      if (type === 'NOT') {
        expression = `~${inputWires[0]}`;
      } else {
        // Вибираємо оператор
        const op = (type === 'AND' || type === 'NAND') ? '&' :
                   (type === 'OR'  || type === 'NOR')  ? '|' :
                   (type === 'XOR') ? '^' : '&';
        
        // З'єднуємо: (A & B & C)
        expression = inputWires.join(` ${op} `);
        
        // Інверсія для NAND/NOR
        if (type === 'NAND' || type === 'NOR') expression = `~(${expression})`;
      }

      code += `    assign ${outputWire} = ${expression};\n`;
    }
  });

  code += `\n    // Output assignments (прив'язка до фізичних виходів)\n`;
  
  outputs.forEach(outNode => {
    const edge = edges.find(e => e.target === outNode.id);
    const outName = sanitize(outNode.data.label || `out_${outNode.id}`);
    
    if (edge) {
      const sourceNode = nodes.find(n => n.id === edge.source);
      let sourceWire = "1'b0";
      
      if (sourceNode.type === 'inputNode') sourceWire = sanitize(sourceNode.data.label || `in_${sourceNode.id}`);
      else if (sourceNode.type === 'logicGate') sourceWire = `wire_${sanitize(sourceNode.id)}`;
      else if (sourceNode.type === 'constantNode') sourceWire = `1'b${sourceNode.data.value}`;

      code += `    assign ${outName} = ${sourceWire};\n`;
    } else {
      code += `    assign ${outName} = 1'b0;\n`;
    }
  });

  code += `\nendmodule\n`;
  return code;
};